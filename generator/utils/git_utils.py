"""
Git utilities for AI Skill Factory local execution.
Handles automatic staging, committing, and pushing of generated content.
"""

import subprocess
from pathlib import Path
from typing import Optional, Tuple, List


def run_git_command(
    args: List[str],
    cwd: Optional[Path] = None,
    timeout: int = 60,
) -> Tuple[bool, str]:
    """Run a git command and return (success, output).

    Args:
        args: Git command arguments (without 'git' prefix)
        cwd: Working directory for the command
        timeout: Command timeout in seconds

    Returns:
        Tuple of (success: bool, output: str)
    """
    try:
        result = subprocess.run(
            ["git"] + args,
            cwd=cwd,
            capture_output=True,
            text=True,
            timeout=timeout,
            encoding="utf-8",
        )
        output = (result.stdout + result.stderr).strip()
        return result.returncode == 0, output
    except subprocess.TimeoutExpired:
        return False, f"Git command timed out after {timeout}s"
    except Exception as e:
        return False, str(e)


def has_changes(repo_dir: Path) -> bool:
    """Check if there are uncommitted changes in the repository.

    Args:
        repo_dir: Path to the git repository

    Returns:
        True if there are uncommitted changes
    """
    success, output = run_git_command(["status", "--porcelain"], repo_dir)
    return success and bool(output.strip())


def get_newest_skill_dir(skills_dir: Path) -> Optional[str]:
    """Get the name of the most recently modified skill directory.

    Args:
        skills_dir: Path to the skills directory

    Returns:
        Name of the newest skill directory, or None
    """
    if not skills_dir.exists():
        return None

    skill_dirs = [d for d in skills_dir.iterdir() if d.is_dir()]
    if not skill_dirs:
        return None

    # Sort by modification time, newest first
    skill_dirs.sort(key=lambda d: d.stat().st_mtime, reverse=True)
    return skill_dirs[0].name


def commit_and_push(
    repo_dir: Path,
    skill_name: Optional[str] = None,
    push: bool = True,
) -> Tuple[bool, str]:
    """Stage, commit, and optionally push generated skill changes.

    Args:
        repo_dir: Path to the git repository
        skill_name: Name of the skill for commit message (auto-detected if None)
        push: Whether to push after committing

    Returns:
        Tuple of (success: bool, message: str)
    """
    messages: List[str] = []

    # Auto-detect skill name if not provided
    if not skill_name:
        skills_dir = repo_dir / "skills"
        skill_name = get_newest_skill_dir(skills_dir) or "new-skill"

    # Stage specific paths
    paths_to_add = [
        "skills/",
        "_posts/",
        "_data/skill_registry.yml",
    ]

    for path in paths_to_add:
        full_path = repo_dir / path
        if full_path.exists() or "*" in path:
            success, output = run_git_command(["add", path], repo_dir)
            if not success:
                messages.append(f"Warning: Could not stage {path}: {output}")

    # Check if there are staged changes
    success, output = run_git_command(["diff", "--staged", "--quiet"], repo_dir)
    if success:  # Exit code 0 means no differences
        return True, "No changes to commit"

    # Create commit message
    commit_msg = f"feat(skill): Add new skill - {skill_name}"
    commit_body = "Generated by AI Skill Factory (local)"
    co_author = "Co-Authored-By: Claude <noreply@anthropic.com>"

    # Commit
    success, output = run_git_command(
        ["commit", "-m", commit_msg, "-m", commit_body, "-m", co_author],
        repo_dir,
    )

    if not success:
        return False, f"Commit failed: {output}"
    messages.append(f"Committed: {skill_name}")

    # Push if requested
    if push:
        print("  Pushing to remote...", flush=True)
        success, output = run_git_command(["push"], repo_dir, timeout=120)
        if not success:
            return False, f"Push failed: {output}"
        messages.append("Pushed to remote")

    return True, "; ".join(messages)


def ensure_clean_state(repo_dir: Path) -> Tuple[bool, str]:
    """Ensure the repository is in a clean state before generation.

    Args:
        repo_dir: Path to the git repository

    Returns:
        Tuple of (is_clean: bool, message: str)
    """
    # Check for uncommitted changes
    success, output = run_git_command(["status", "--porcelain"], repo_dir)
    if not success:
        return False, f"Failed to check git status: {output}"

    if output.strip():
        return False, f"Repository has uncommitted changes:\n{output}"

    return True, "Repository is clean"


def pull_latest(repo_dir: Path) -> Tuple[bool, str]:
    """Pull latest changes from remote.

    Args:
        repo_dir: Path to the git repository

    Returns:
        Tuple of (success: bool, message: str)
    """
    success, output = run_git_command(["pull", "--ff-only"], repo_dir, timeout=120)
    if not success:
        return False, f"Pull failed: {output}"
    return True, output or "Already up to date"
