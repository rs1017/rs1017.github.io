---
layout: post
title: "게임 서버 상태 관리를 위한 CRDT 구현 및 성능 분석"
date: 2026-01-19 19:37:02 +0900
categories: [Tech]
tags: [CRDT, 분산시스템, 게임서버, 동기화]
image:
  path: /assets/img/posts/2026-01-19-게임-서버-상태-관리를-위한-crdt-구현-및-성능-분석/main.jpg
  alt: 게임 서버 상태 관리를 위한 CRDT 구현 및 성능 분석
---

# PvP는 Lock으로, 인벤토리는 CRDT로: 게임 상태에 따른 최적의 CRDT 타입(CvRDT/OpCRDT) 선택 가이드

## I. 분산 게임 서버의 영원한 숙제: 네트워크 지연과 상태 충돌

대규모 멀티플레이어 게임(MMO) 서버 아키텍처의 핵심 난제는 **저지연(Low Latency)** 환경에서 **상태 일관성(State Consistency)**을 유지하는 것입니다. 전통적인 권위적 서버(Authoritative Server) 모델은 모든 상태 변경에 대해 중앙 서버의 락(Lock) 또는 트랜잭션 검증을 요구합니다. 이는 시스템의 선형적 확장성을 저해하는 주범이며, 특히 글로벌 서비스 환경에서 네트워크 지연이 수백 밀리초에 달할 때 사용자 경험을 심각하게 저해합니다.

수천, 수만 명의 동시 접속자가 아이템을 획득하고, 재화를 소비하며, 월드 오브젝트를 조작할 때, 중앙 통제 방식은 결국 병목 현상(Bottleneck)에 직면합니다. 우리는 이 병목 현상을 해소하고, 고가용성을 확보하기 위해 일관성 모델 자체를 재정의할 필요가 있습니다.

이 글은 중앙 조정 없이도 **수렴적 일관성(Strong Eventual Consistency, SEC)**을 보장하는 **CRDT(Conflict-free Replicated Data Types)**가 게임 서버의 특정 상태 관리 문제를 어떻게 해결할 수 있는지 심층 분석합니다.

## II. 충돌 없는 데이터 타입: CRDT란 무엇이며, 왜 게임 서버에 필요한가?

CRDT는 분산 시스템의 여러 복제본(Replica)이 독립적으로 상태를 변경하더라도, 모든 업데이트가 전파되면 **충돌 없이 최종적으로 동일한 상태로 수렴함**을 수학적으로 보장하는 데이터 타입입니다.

CRDT의 핵심은 **단조성(Monotonicity)**과 **가환성(Commutativity)**입니다. 즉, 상태가 한 방향으로만 변경되고(데이터 추가, 카운터 증가 등), 업데이트 순서에 관계없이 병합 결과가 동일해야 합니다.

### CRDT가 해결할 수 있는 게임 상태

모든 게임 상태에 CRDT가 적합한 것은 아닙니다. CRDT는 **'누가 먼저 했는가'보다 '무엇을 했는가'가 중요한** 상태 관리에 최적화되어 있습니다.

| CRDT 적합 상태 | 특징 |
| :--- | :--- |
| **인벤토리/재화 카운터** | 아이템 획득(+1), 사용(-1) 등 트랜잭션 순서보다는 최종 합계가 중요. |
| **월드 오브젝트 상태** | 건축물의 파괴/수리 상태, 문 열림/닫힘 상태 등 최종 결과 상태가 중요. |
| **길드/파티 초대 목록** | 누가 누구를 초대했는지 기록하며, 최종 목록의 합이 중요. |
| **채팅/활동 로그** | 순서는 중요하지만, 두 개의 메시지 목록을 병합할 때 충돌이 없어야 함. |

CRDT를 사용하면 락이나 분산 트랜잭션(2PC/3PC)의 비용을 지불하지 않고도 상태 업데이트가 가능하므로, **레이턴시를 극적으로 낮출** 수 있습니다. 이는 중앙 집중식 일관성 비용을 분산된 메타데이터 관리 비용(벡터 클락 등)으로 전환하는 아키텍처적 선택입니다.

## III. CvRDT vs. OpCRDT: 대역폭과 인과성 사이의 트레이드오프 분석

CRDT는 크게 두 가지 유형으로 나뉩니다. 어떤 타입을 선택하느냐는 서버의 **대역폭 요구 사항**과 **상태 변경 빈도**에 따라 달라집니다.

### 1. CvRDT (State-based CRDT)
*CvRDT: Convergent Replicated Data Type*

CvRDT는 현재 **전체 상태(State)**를 다른 복제본으로 전송하며, 수신 측은 단순히 **상태 병합(Merge)** 함수를 사용하여 자신의 로컬 상태와 외부 상태를 합칩니다.

CvRDT의 장점은 병합 로직이 단순하며, 네트워크에서 메시지 손실이 발생해도 최종 상태가 항상 수렴한다는 점입니다 (상태 자체를 전송하므로).

### 2. OpCRDT (Operation-based CRDT)
*OpCRDT: Operation-based Replicated Data Type*

OpCRDT는 상태 자체가 아닌 **발생한 작업(Operation)**만을 전송합니다. 수신 측은 이 작업(예: `Increment(1)`)을 로컬 상태에 적용(Apply)합니다.

OpCRDT의 가장 큰 장점은 **대역폭 사용량이 CvRDT보다 훨씬 적다**는 것입니다. 그러나 치명적인 단점은 작업의 **인과 관계(Causality)**를 보장해야 한다는 것입니다. 즉, 필요한 선행 작업이 먼저 적용되지 않으면 시스템 일관성이 깨질 수 있습니다. 이를 위해 보통 **벡터 클락(Vector Clocks)** 같은 메타데이터를 사용하여 작업 순서를 보장해야 합니다.

| 특징 | CvRDT (State-based) | OpCRDT (Operation-based) |
| :--- | :--- | :--- |
| **전송 데이터** | 전체 상태 (`State`) | 변경 작업 (`Operation`) |
| **네트워크 요구** | 신뢰성 낮아도 무방 (상태만 받으면 됨) | **인과성(Causality) 보장 필수** |
| **대역폭** | 높음 (데이터 크기에 비례) | 낮음 (작업 크기에 비례) |
| **사용 사례** | 상태가 작고 자주 변경됨 (예: 작은 카운터, 핑/하트비트) | 상태가 크고 작업 빈도가 낮음 (예: 대형 맵 오브젝트, 문서 편집) |

**선택 가이드:**

*   **인벤토리/재화 카운터**처럼 상태 크기가 작고 동시 업데이트가 잦다면, 로직이 단순한 **CvRDT**를 고려하십시오.
*   **길드 게시판**이나 **대규모 건축물**처럼 데이터 구조가 복잡하고 작업 자체만 전송해도 충분한 경우, 대역폭 최적화를 위해 **OpCRDT**를 사용하는 것이 유리합니다.

## IV. CRDT 수렴의 마법: 격자 구조(Lattice)와 병합 함수의 역할

CRDT가 충돌 없이 수렴하는 근본적인 이유는 수학적 구조인 **반순서 집합(Partially Ordered Set)**과 **격자 구조(Lattice)** 덕분입니다.

CRDT의 상태 공간은 격자 구조를 형성합니다. 이 격자에서 데이터 상태는 단조롭게(Monotonically) 증가합니다. 상태 A와 상태 B가 충돌했을 때, CRDT의 병합 함수는 A와 B의 **최소 상계(Least Upper Bound, LUB)**를 찾아내며, 이 LUB는 항상 유일합니다.

이 LUB 연산이 성립하기 위해 CRDT는 다음과 같은 속성을 만족하는 병합 함수 $\text{Merge}(A, B)$를 가져야 합니다.

1.  **교환성 (Commutativity):** $\text{Merge}(A, B) = \text{Merge}(B, A)$ (순서에 무관하게 결과 동일)
2.  **결합성 (Associativity):** $\text{Merge}(A, \text{Merge}(B, C)) = \text{Merge}(\text{Merge}(A, B), C)$
3.  **멱등성 (Idempotence):** $\text{Merge}(A, A) = A$ (같은 상태를 여러 번 병합해도 결과는 동일)

### 메타데이터 비용: 벡터 클락의 사용

CvRDT의 경우 단순한 카운터라면 메타데이터 비용이 적지만, 삭제(Remove) 연산이 포함되는 `Set` 타입(예: OR-Set)이나 OpCRDT의 경우 메타데이터가 필수적입니다.

특히 OpCRDT에서 벡터 클락이 필요한 주된 이유는 **인과성 보장**과 **멱등성 보장**입니다. 벡터 클락은 각 복제본이 다른 복제본의 어떤 업데이트까지 적용했는지 기록하며, 이를 통해:

1.  선행 작업이 도착하지 않은 상태에서 후행 작업이 적용되는 것을 방지합니다.
2.  이미 적용된 작업을 다시 적용하려 할 때(멱등성 위반), 이를 걸러내어 중복 적용으로 인한 상태 오염을 막습니다.

이 메타데이터는 데이터 크기를 증가시키고 직렬화/역직렬화 오버헤드를 유발합니다. CRDT를 설계할 때 이 **메타데이터 오버헤드**를 관리하는 것이 성능 최적화의 핵심입니다.

## V. 성능 분석: 메모리 오버헤드 극복을 위한 최적화 전략 3가지

CRDT는 저지연 통신에 매우 강력하지만, 장기적으로 시스템을 운영할 때 두 가지 주요 단점이 발생합니다. **메모리 사용량 증가**와 **병합 시간 증가**입니다.

### 1. 대역폭 최적화: Delta-CRDT 활용

CvRDT는 전체 상태를 전송하기 때문에 복잡하고 큰 데이터 구조에서는 대역폭 낭비가 심합니다. 이를 해결하기 위해 **Delta-CRDT** 기법을 사용합니다.

Delta-CRDT는 상태 전체를 보내는 대신, **이전 동기화 이후 변경된 부분 집합(Delta)**만 전송합니다. 이는 OpCRDT와 유사하게 보이지만, Delta-CRDT는 상태 기반(State-based)의 병합 로직을 유지하므로 인과성 보장이 필요하지 않다는 장점이 있습니다. 수신 측은 전체 상태가 아닌 델타 상태만을 병합하여 효율을 높입니다.

**최적화 적용:** 데이터 전송 시 JSON 대신 **Protobuf**나 **MessagePack** 같은 고효율 직렬화 포맷을 사용하여 델타 크기를 최소화해야 합니다.

### 2. 메모리 최적화: 툼스톤(Tombstone) 가비지 컬렉션(GC)

CRDT는 단조성을 유지해야 하므로, 데이터 삭제(Remove)는 단순히 데이터를 제거하는 것이 아니라 **'삭제 기록'**을 남겨야 합니다. 이 삭제 기록을 **툼스톤(Tombstone)**이라고 부릅니다.

예를 들어, G-Set(Grow-only Set)에 삭제 기능을 추가한 OR-Set(Observed-Remove Set)은 요소를 추가한 기록(Add)과 삭제한 기록(Remove)을 모두 별도의 메타데이터로 관리합니다. 시간이 지날수록 사용하지 않는 툼스톤이 메모리를 점유하게 됩니다.

**툼스톤 GC 전략:** 모든 복제본이 특정 툼스톤을 확인하고 적용했음이 벡터 클락 등으로 증명되는 시점(Garbage Collection Threshold)을 설정하고, 이 시점이 지난 툼스톤을 일괄 제거해야 합니다. 이는 CRDT 운영의 필수적인 유지보수 작업입니다.

### 3. 병합 속도 최적화: CRDT 범위 제한(Scoping)

CRDT의 병합 시간은 일반적으로 데이터 크기에 비례합니다. 단일 CRDT 객체가 너무 커지면 병합 자체가 병목이 될 수 있습니다.

**해결책:** 게임 월드나 인벤토리 전체를 하나의 거대한 CRDT로 관리하는 대신, **Scope를 제한**하여 작은 CRDT 객체의 집합으로 관리해야 합니다.

*   예: 인벤토리 전체를 하나의 OR-Set으로 관리하는 대신, 100칸짜리 인벤토리를 10개씩 묶어 10개의 작은 OR-Set으로 분할합니다. 각 복제본은 필요한 부분(Scope)만 동기화하고 병합합니다.

## VI. 실제 사례 분석: CRDT가 빛을 발하는 게임 서버 상태들

### PN-Counter: 재화 및 자원 관리

**PN-Counter (Positive-Negative Counter)**는 증가(+P)와 감소(-N) 연산을 분리된 두 개의 `G-Counter` (Grow-only Counter)로 관리합니다.

$$ \text{Value} = \text{P} - \text{N} $$

두 복제본이 PN-Counter를 병합할 때, 각 복제본은 자신의 P 카운터와 N 카운터를 다른 복제본의 P 카운터, N 카운터와 병합합니다. G-Counter의 병합은 단순히 두 값 중 **최댓값(Supremum)**을 취하는 방식(Set Union)입니다. 이는 충돌 없는 합산 결과를 보장합니다.

아래는 PN-Counter의 핵심 구조 및 병합 함수에 대한 예시입니다.

```python
# Python 예시: PN-Counter 구조체 및 병합 로직

class PNCounter:
    def __init__(self, replica_id):
        self.id = replica_id
        # {replica_id: count} 형태의 딕셔너리
        self.P = {}  # 증가 카운터 (Positive)
        self.N = {}  # 감소 카운터 (Negative)

    def increment(self, amount):
        current_p = self.P.get(self.id, 0)
        self.P[self.id] = current_p + amount

    def decrement(self, amount):
        current_n = self.N.get(self.id, 0)
        self.N[self.id] = current_n + amount

    def value(self):
        # 최종 값 = P 합계 - N 합계
        total_p = sum(self.P.values())
        total_n = sum(self.N.values())
        return total_p - total_n

    def merge(self, other_counter):
        # 병합 함수: 각 P와 N 카운터의 최댓값(Max)을 취한다.
        # G-Counter의 병합은 MAX 연산이다.
        
        # P 카운터 병합
        for rid, count in other_counter.P.items():
            current_p = self.P.get(rid, 0)
            self.P[rid] = max(current_p, count)
            
        # N 카운터 병합
        for rid, count in other_counter.N.items():
            current_n = self.N.get(rid, 0)
            self.N[rid] = max(current_n, count)
            
        return self
```

### OR-Set 및 RGA: 월드 오브젝트 및 채팅 시스템

1.  **OR-Set (Observed-Remove Set):** 인벤토리 아이템 관리나 월드 오브젝트 목록 관리에 유용합니다. 복수의 클라이언트가 동시에 아이템을 추가하고 삭제해도 충돌 없이 최종 목록이 완성됩니다.
2.  **RGA (Replicated Growable Array):** 채팅 메시지나 플레이어 활동 로그(Activity Log)처럼 삽입 순서가 중요한 시퀀스 데이터 관리에 사용됩니다. RGA는 텍스트 편집기 CRDT의 핵심 원리인 **인덱스 식별자**를 사용하여 병합 시 순서 충돌을 해결합니다.

## VII. CRDT는 만병통치약인가? 분산 게임 아키텍처의 미래 방향

CRDT는 저지연 분산 시스템을 구축하는 데 혁명적인 도구이지만, 모든 문제를 해결하는 만병통치약은 아닙니다.

### CRDT가 부적합한 영역

**높은 시간 정확성을 요구하는 상태:** CRDT는 SEC(Strong Eventual Consistency)를 목표로 합니다.
1.  **PvP 핵심 로직 및 히트 판정:** 10ms 단위의 정확한 동기화가 필요한 물리 시뮬레이션이나 전투 시스템은 전통적인 **권위적 서버(Lock-step 또는 Rollback Netcode)** 모델이 필수적입니다.
2.  **치명적인 보안 문제:** 핵(Cheat) 방지가 최우선인 경우, 클라이언트의 상태 변경을 쉽게 수용하는 CRDT 모델은 위험할 수 있습니다. (재화 충돌 방지에는 유용하지만, 무한 복사 방지에는 중앙 검증이 필요합니다.)

### 하이브리드 아키텍처의 필요성

가장 현실적인 게임 서버 아키텍처는 CRDT와 권위적 서버 모델을 혼합하는 **하이브리드 접근법**입니다.

*   **PvP 코어 전투:** 중앙 서버에서 **락 기반**의 실시간 상태 동기화 및 검증을 수행하여 핵과 충돌을 방지합니다.
*   **비핵심 상태 (Inventory, Guild State, Resources):** CRDT를 사용하여 클라이언트가 즉시 업데이트를 수행하고, 서버 간 병합을 비동기적으로 처리하여 **지연을 최소화**합니다.

CRDT는 분산 시스템의 일관성 비용을 레이턴시 측면에서 사용자에게 전가하는 대신, 서버 내부의 메타데이터 관리 및 병합 비용으로 치환합니다. 대규모 고가용성 게임 서버를 설계하는 시니어 아키텍트라면, CRDT의 수학적 배경과 성능 트레이드오프를 명확히 이해하고 상태별로 적절한 일관성 모델을 선택해야 할 것입니다.

*(This post was automatically generated by AI Agent Pipeline)*
